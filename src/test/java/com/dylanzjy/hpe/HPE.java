package com.dylanzjy.hpe;

import com.dylanzjy.hpe.base.entity.CipherText;
import com.dylanzjy.hpe.base.entity.CommonConstants;
import com.dylanzjy.hpe.base.key.HPEKeyPair;
import com.dylanzjy.hpe.base.key.HPEPrivateKey;
import com.dylanzjy.hpe.base.key.HPEPublicKey;
import com.dylanzjy.hpe.base.key.HPESecretKey;
import com.dylanzjy.hpe.base.param.*;
import com.dylanzjy.hpe.core.HPEEncryptService;
import com.dylanzjy.hpe.core.HPEPredicateOnlyService;
import com.dylanzjy.hpe.generator.HPEDelegationGenerator;
import com.dylanzjy.hpe.generator.HPEKeyGenerator;
import com.dylanzjy.hpe.generator.HPEKeyPairGenerator;
import com.dylanzjy.hpe.util.HPEParametersHolder;
import it.unisa.dia.gas.jpbc.Element;
import it.unisa.dia.gas.jpbc.Pairing;
import it.unisa.dia.gas.plaf.jpbc.pairing.PairingFactory;
import junit.framework.Assert;

import java.util.Random;

/**
 * Created by zhangjiayi on 2017/2/17.
 */
public class HPE {
    private HPEPredicateOnlyService predicate = new HPEPredicateOnlyService();

    private HPEEncryptService encryption = new HPEEncryptService();

    /**
     * set up key pair
     * @param n the number of attributes
     */
    public HPEKeyPair setUp(int n) {
        HPEKeyPairGenerator keyPairGenerator = new HPEKeyPairGenerator();
        return keyPairGenerator.generateKeyPair(createParameters(n));
    }

    /**
     * generate attributes index
     * @param x attributes vector
     */
    public CipherText encryptForEvaluation(HPEPublicKey publicKey, Element[][] x) {
        return predicate.encrypt(new HPEEncryptionParameters(publicKey, x));
    }

    /**
     * evaluate whether the secretKey matches index
     */
    public boolean evaluate(HPESecretKey secretKey, CipherText cipherText) {
        return predicate.evaluate(new HPEDecryptionParameters(secretKey, cipherText));
    }

    /**
     * generate l level secret key
     * @param v predicate vector
     */
    public HPESecretKey keyGen(HPEPrivateKey privateKey, Element[][] v) {
        HPEKeyGenerator keyGenerator = new HPEKeyGenerator();
        return keyGenerator.generateSecretKey(new HPEKeyGenParameters(privateKey, v));
    }

    /**
     * delegation method
     * @param secretKey secret key generated by keyGen or delegate
     * @param v (l + 1) level predicate vector
     * @return
     */
    public HPESecretKey delegate(HPESecretKey secretKey, Element[] v) {
        HPEDelegationGenerator generator = new HPEDelegationGenerator();
        return generator.generateDelegation(new HPEDelegationParameters(secretKey, v));
    }

    /**
     * encrypt a GTField number
     */
    public CipherText encrypt(HPEPublicKey publicKey, Element[][] x, Element m) {
        return encryption.encrypt(new HPEEncryptionParameters(publicKey, x, m));
    }

    /**
     * decryption
     */
    public Element decrypt(HPESecretKey secretKey, CipherText cipherText) {
        return encryption.decrypt(new HPEDecryptionParameters(secretKey, cipherText));
    }


    public static void main(String[] args) {
        // number of attributes, should be even in this test case
        int n = 4;

        HPE hpe = new HPE();
        HPEKeyPair keyPair = hpe.setUp(n);

        Pairing pairing = HPEParametersHolder.getParameters(CommonConstants.key).getPairing();

        // attribute vector
        Element[][] X = new Element[2][n];
        // predicate vector
        Element[][] V = new Element[2][n];
        // predicate vector for delegation
        Element[] Vl = new Element[n];

        hpe.createOrthogonalVectors(X, V, Vl);

        // test for evaluation
        CipherText ev = hpe.encryptForEvaluation(keyPair.getPublicKey(), X);
        HPESecretKey evKey = hpe.keyGen(keyPair.getPrivateKey(), V);
        Assert.assertEquals(true, hpe.evaluate(evKey, ev));

        // test for encryption
        evKey = hpe.delegate(evKey, Vl);
        Element m = pairing.getGT().newRandomElement();
        CipherText cm = hpe.encrypt(keyPair.getPublicKey(), X, m);
        Assert.assertEquals(true, m.equals(hpe.decrypt(evKey, cm)));
    }


    /**
     * set curve parameters
     * @param n the number of attributes
     */
    private HPEParameters createParameters(int n) {
        HPEParameters parameters =  new HPEParameters(
                PairingFactory.getPairingParameters("curves/a.properties"), n);
        HPEParametersHolder.set(CommonConstants.key, parameters);
        return parameters;
    }

    private void createOrthogonalVectors(Element[][] X, Element[][] V, Element[] Vl) {
        Pairing pairing = HPEParametersHolder.getParameters(CommonConstants.key).getPairing();

        Random random = new Random();
        for (int i = 0; i < Vl.length; i += 2) {
            if (random.nextBoolean()) {
                X[0][i] = pairing.getZr().newZeroElement();
                X[0][i + 1] = pairing.getZr().newZeroElement();
                X[1][i] = pairing.getZr().newOneElement();
                X[1][i + 1] = pairing.getZr().newRandomElement();

                V[0][i] = pairing.getZr().newZeroElement();
                V[0][i + 1] = pairing.getZr().newZeroElement();
                V[1][i] = pairing.getZr().newZeroElement();
                V[1][i + 1] = pairing.getZr().newZeroElement();

                Vl[i] = X[1][i + 1].duplicate().negate();
                Vl[i + 1] = pairing.getZr().newOneElement();
            } else {
                X[0][i] = pairing.getZr().newOneElement();
                X[0][i + 1] = pairing.getZr().newRandomElement();
                X[1][i] = pairing.getZr().newZeroElement();
                X[1][i + 1] = pairing.getZr().newZeroElement();

                V[0][i] = X[0][i + 1].duplicate().negate();
                V[0][i + 1] = pairing.getZr().newOneElement();
                V[1][i] = pairing.getZr().newZeroElement();
                V[1][i + 1] = pairing.getZr().newZeroElement();

                Vl[i] = X[0][i + 1].duplicate().negate();
                Vl[i + 1] = pairing.getZr().newOneElement();
            }
        }
    }

}
